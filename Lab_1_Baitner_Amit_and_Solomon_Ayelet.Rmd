---
title: "52414 - lab 1"
author: "Ayelet Solomon 319096962, Amit Baitner 205373947"
date: "4/4/2020"
output: html_document
---

# *Lab 1: Basic Data Wrangling*  
<br/><br/>  
  

**Contents**:  

* Q0) [Submission Instructions](#submission-instructions)  
* Q1) [Data Preparation and Manipulation](#data-preparation-and-manipulation)      
* Q2) [Analysis of Daily New Corona Cases and Deaths](#analysis-of-daily-new-corona-cases-and-deaths)    
* Q3) [Preparing and Analyzing the World Bank Data](#preparing-and-analyzing-the-world-bank-data)
* Q4) [Joining the Datasets](#joining-the-datasets)  
* Q5)   [Open Question](#open-question)

<br/><br/>
  
  
### Submission Instructions  
  
This lab will be submitted in pairs using GitHub (if you don't have a pair, please contact us).  
Please follow the steps in the  [GitHub-Classroom Lab 1](https://classroom.github.com/g/oSZNtHq4) to create your group's Lab 1 repository.  
**Important: your team's name must be `FamilyName1_Name1_and_FamilyName2_Name2`**.  
You can collaborate with your partner using the git environment; You can either make commits straight to master, or create individual branches (recommended). However, once done, be sure to merge your branches to master - you will be graded using the most recent master version - your last push and merge before the deadline.   
**Please do not open/review other peoples' repositories - we will be notified by GitHub if you do.**

Your final push should include this Rmd file (with your answers) together with the html file that is outputted automatically by knitr when you knit the Rmd. Anything else will be disregarded. In addition, please adhere to the following file format:    
`Lab_2_FamilyName1_Name1_and_FamilyName2_Name2.Rmd/html`      


<br/><br/>
  
The only allowed libraries are the following (**please do not add your own**):
```{r, include=FALSE}
library('tidyverse')
library(data.table)
```  
<br/><br/>

## A Deeper Dive Into John's Hopkins Corona Database         
    
The John's Hopkins Novel Corona Virus (COVID-19) epidemiological data is compiled by the Johns Hopkins University Center for Systems Science and Engineering (JHU CCSE) from various sources. <br>
The dataset contains data since 22nd of January 2020. For the data and more information about it, please visit [here](https://data.humdata.org/dataset/novel-coronavirus-2019-ncov-cases).    
  
In this lab you will pick up where we left in lecture 2 and analyze the Corona cases and deaths data.  

### Q1
### Data Preparation and Manipulation   
(25 points)  

1. We first prepare and aggregate the data.   

a. First, load the `Corona Confirmed Cases Narrow`, the `Corona Confirmed Deaths Narrow`, and the `Corona Confirmed Recovered Narrow` datasets directly from the John's Hopkins website.  
The type of the `Date` variable should be date type. (2 pts)      
b. Create new data-frames named `cases.agg`, `deaths.agg`, and `recovered.agg` which aggregate the `sum` of Corona cases, deaths, and recovered respectively over the different countries' provinces. To do this, aggregate `Value` using only the country and date features, ignoring all other features (similarly to what has been shown in `lecture 2`).  
To achieve the aggregation use the `aggregate` function. In addition, order the data-frame first by Country and then by Date (increasing order). The columns of each of the two resulting data-frames should be `Country.Region, Date, Value`. (5pts)   
c. Repeat (b) using `tidyverse` and the pipe. Show that the outputs from the two methods are the same. (5pts)  
d. Using the last day of March as a reference, create a single stacked bar-plot that visualizes the top 10 countries in terms of their Corona cases, and their respected Corona deaths and recovered cases stacked on top of the current sick people in three different colors (each stack should add up to total cases). Make sure that the first bar shows the number of confirmed Corona sick people (`sick = cases - deaths - recovered`). What is the biggest issue with the information presented in this plot? (13pts)

   
  
**Solution:**  

**Q1.**
**we loaded the data from John's Hopkins Corona Database for cases, deaths and recovered number of people.**
```{r}
#a
conf_cases <- read.csv(url("https://data.humdata.org/hxlproxy/data/download/time_series_covid19_confirmed_global_narrow.csv?dest=data_edit&filter01=merge&merge-url01=https%3A%2F%2Fdocs.google.com%2Fspreadsheets%2Fd%2Fe%2F2PACX-1vTglKQRXpkKSErDiWG6ycqEth32MY0reMuVGhaslImLjfuLU0EUgyyu2e-3vKDArjqGX7dXEBV8FJ4f%2Fpub%3Fgid%3D1326629740%26single%3Dtrue%26output%3Dcsv&merge-keys01=%23country%2Bname&merge-tags01=%23country%2Bcode%2C%23region%2Bmain%2Bcode%2C%23region%2Bsub%2Bcode%2C%23region%2Bintermediate%2Bcode&filter02=merge&merge-url02=https%3A%2F%2Fdocs.google.com%2Fspreadsheets%2Fd%2Fe%2F2PACX-1vTglKQRXpkKSErDiWG6ycqEth32MY0reMuVGhaslImLjfuLU0EUgyyu2e-3vKDArjqGX7dXEBV8FJ4f%2Fpub%3Fgid%3D398158223%26single%3Dtrue%26output%3Dcsv&merge-keys02=%23adm1%2Bname&merge-tags02=%23country%2Bcode%2C%23region%2Bmain%2Bcode%2C%23region%2Bsub%2Bcode%2C%23region%2Bintermediate%2Bcode&merge-replace02=on&merge-overwrite02=on&filter03=explode&explode-header-att03=date&explode-value-att03=value&filter04=rename&rename-oldtag04=%23affected%2Bdate&rename-newtag04=%23date&rename-header04=Date&filter05=rename&rename-oldtag05=%23affected%2Bvalue&rename-newtag05=%23affected%2Binfected%2Bvalue%2Bnum&rename-header05=Value&filter06=clean&clean-date-tags06=%23date&filter07=sort&sort-tags07=%23date&sort-reverse07=on&filter08=sort&sort-tags08=%23country%2Bname%2C%23adm1%2Bname&tagger-match-all=on&tagger-default-tag=%23affected%2Blabel&tagger-01-header=province%2Fstate&tagger-01-tag=%23adm1%2Bname&tagger-02-header=country%2Fregion&tagger-02-tag=%23country%2Bname&tagger-03-header=lat&tagger-03-tag=%23geo%2Blat&tagger-04-header=long&tagger-04-tag=%23geo%2Blon&header-row=1&url=https%3A%2F%2Fraw.githubusercontent.com%2FCSSEGISandData%2FCOVID-19%2Fmaster%2Fcsse_covid_19_data%2Fcsse_covid_19_time_series%2Ftime_series_covid19_confirmed_global.csv"),header=T,comment.char = "#")

conf_deaths <- read.csv(url("https://data.humdata.org/hxlproxy/data/download/time_series_covid19_deaths_global_narrow.csv?dest=data_edit&filter01=merge&merge-url01=https%3A%2F%2Fdocs.google.com%2Fspreadsheets%2Fd%2Fe%2F2PACX-1vTglKQRXpkKSErDiWG6ycqEth32MY0reMuVGhaslImLjfuLU0EUgyyu2e-3vKDArjqGX7dXEBV8FJ4f%2Fpub%3Fgid%3D1326629740%26single%3Dtrue%26output%3Dcsv&merge-keys01=%23country%2Bname&merge-tags01=%23country%2Bcode%2C%23region%2Bmain%2Bcode%2C%23region%2Bsub%2Bcode%2C%23region%2Bintermediate%2Bcode&filter02=merge&merge-url02=https%3A%2F%2Fdocs.google.com%2Fspreadsheets%2Fd%2Fe%2F2PACX-1vTglKQRXpkKSErDiWG6ycqEth32MY0reMuVGhaslImLjfuLU0EUgyyu2e-3vKDArjqGX7dXEBV8FJ4f%2Fpub%3Fgid%3D398158223%26single%3Dtrue%26output%3Dcsv&merge-keys02=%23adm1%2Bname&merge-tags02=%23country%2Bcode%2C%23region%2Bmain%2Bcode%2C%23region%2Bsub%2Bcode%2C%23region%2Bintermediate%2Bcode&merge-replace02=on&merge-overwrite02=on&filter03=explode&explode-header-att03=date&explode-value-att03=value&filter04=rename&rename-oldtag04=%23affected%2Bdate&rename-newtag04=%23date&rename-header04=Date&filter05=rename&rename-oldtag05=%23affected%2Bvalue&rename-newtag05=%23affected%2Binfected%2Bvalue%2Bnum&rename-header05=Value&filter06=clean&clean-date-tags06=%23date&filter07=sort&sort-tags07=%23date&sort-reverse07=on&filter08=sort&sort-tags08=%23country%2Bname%2C%23adm1%2Bname&tagger-match-all=on&tagger-default-tag=%23affected%2Blabel&tagger-01-header=province%2Fstate&tagger-01-tag=%23adm1%2Bname&tagger-02-header=country%2Fregion&tagger-02-tag=%23country%2Bname&tagger-03-header=lat&tagger-03-tag=%23geo%2Blat&tagger-04-header=long&tagger-04-tag=%23geo%2Blon&header-row=1&url=https%3A%2F%2Fraw.githubusercontent.com%2FCSSEGISandData%2FCOVID-19%2Fmaster%2Fcsse_covid_19_data%2Fcsse_covid_19_time_series%2Ftime_series_covid19_deaths_global.csv"),header=T,comment.char = "#")

conf_recov <- read.csv(url("https://data.humdata.org/hxlproxy/data/download/time_series_covid19_recovered_global_narrow.csv?dest=data_edit&filter01=merge&merge-url01=https%3A%2F%2Fdocs.google.com%2Fspreadsheets%2Fd%2Fe%2F2PACX-1vTglKQRXpkKSErDiWG6ycqEth32MY0reMuVGhaslImLjfuLU0EUgyyu2e-3vKDArjqGX7dXEBV8FJ4f%2Fpub%3Fgid%3D1326629740%26single%3Dtrue%26output%3Dcsv&merge-keys01=%23country%2Bname&merge-tags01=%23country%2Bcode%2C%23region%2Bmain%2Bcode%2C%23region%2Bsub%2Bcode%2C%23region%2Bintermediate%2Bcode&filter02=merge&merge-url02=https%3A%2F%2Fdocs.google.com%2Fspreadsheets%2Fd%2Fe%2F2PACX-1vTglKQRXpkKSErDiWG6ycqEth32MY0reMuVGhaslImLjfuLU0EUgyyu2e-3vKDArjqGX7dXEBV8FJ4f%2Fpub%3Fgid%3D398158223%26single%3Dtrue%26output%3Dcsv&merge-keys02=%23adm1%2Bname&merge-tags02=%23country%2Bcode%2C%23region%2Bmain%2Bcode%2C%23region%2Bsub%2Bcode%2C%23region%2Bintermediate%2Bcode&merge-replace02=on&merge-overwrite02=on&filter03=explode&explode-header-att03=date&explode-value-att03=value&filter04=rename&rename-oldtag04=%23affected%2Bdate&rename-newtag04=%23date&rename-header04=Date&filter05=rename&rename-oldtag05=%23affected%2Bvalue&rename-newtag05=%23affected%2Binfected%2Bvalue%2Bnum&rename-header05=Value&filter06=clean&clean-date-tags06=%23date&filter07=sort&sort-tags07=%23date&sort-reverse07=on&filter08=sort&sort-tags08=%23country%2Bname%2C%23adm1%2Bname&tagger-match-all=on&tagger-default-tag=%23affected%2Blabel&tagger-01-header=province%2Fstate&tagger-01-tag=%23adm1%2Bname&tagger-02-header=country%2Fregion&tagger-02-tag=%23country%2Bname&tagger-03-header=lat&tagger-03-tag=%23geo%2Blat&tagger-04-header=long&tagger-04-tag=%23geo%2Blon&header-row=1&url=https%3A%2F%2Fraw.githubusercontent.com%2FCSSEGISandData%2FCOVID-19%2Fmaster%2Fcsse_covid_19_data%2Fcsse_covid_19_time_series%2Ftime_series_covid19_recovered_global.csv"),header=T,comment.char = "#")

```

**a.**
**We changed the data class of the column "Date" to class "Date". To check the class we print the class of the column Date and you can see it is prints the class "Date". **

```{r}
#Changing the date column to date type.
#a
conf_cases$Date <- as.Date(conf_cases$Date)
conf_deaths$Date <- as.Date(conf_deaths$Date)
conf_recov$Date <- as.Date(conf_recov$Date)
print(class(conf_cases$Date))
print(class(conf_deaths$Date))
print(class(conf_recov$Date))
```

**b.**

**we have aggregated the data using a built-in function and created a new data structure for the corona cases, corona deaths and corona recovered. The columns of each of the two resulting data-frames are: `Country.Region, Date, Value` and you can see that on the print we make for every column.**
**We used the "order" function to order the data first by country and then by date.**
```{r}
#b
#Aggregating the data and creating new data frames
cases.agg <- aggregate(Value ~ Country.Region + Date, data= conf_cases, FUN=sum)
cases.agg <- cases.agg[order(cases.agg$Country.Region, cases.agg$Date),]
print(colnames(cases.agg))

deaths.agg <- aggregate(Value ~ Country.Region + Date, data= conf_deaths, FUN=sum)
deaths.agg <- deaths.agg[order(deaths.agg$Country.Region, deaths.agg$Date),]
print(colnames(deaths.agg))

recovered.agg <- aggregate(Value ~ Country.Region + Date, data= conf_recov, FUN=sum)
recovered.agg <- recovered.agg[order(recovered.agg$Country.Region),]
print(colnames(recovered.agg))
```


**c.**

**By using a boolean value you can see that comparing the outputs from the two methods (using the function aggregate and using the pipe method) gives the value TRUE beacouse they are the same.**

```{r}
#c
cases.agg1 <- select(conf_cases, Country.Region, Date, Value)
cases.agg1 <- group_by(cases.agg1, Country.Region, Date) %>% summarize(Value = sum(Value))
#Showing that the two data frames are the same with a boolean 


deaths.agg1 <- select(conf_deaths, Country.Region, Date, Value)
deaths.agg1 <- group_by(deaths.agg1, Country.Region, Date) %>% summarize(Value = sum(Value))
#Showing that the two data frames are the same with a boolean 


recov.agg1 <- select(conf_recov, Country.Region, Date, Value)
recov.agg1 <- group_by(recov.agg1, Country.Region, Date) %>% summarize(Value = sum(Value))
#Showing that the two data frames are the same with a boolean 
all(cases.agg==cases.agg1)
all(deaths.agg==deaths.agg1)
all(recovered.agg==recov.agg1)
```

**d.**

**We filteres the data by the last day of march and then we ordered the data from the largest value down and we chose the top ten countries for the barplot.**

```{r}
#d
#Filtering the data by the last day of march 2020
march_c <- cases.agg[which(cases.agg$Date=="2020-03-31"),]
march_d <- deaths.agg[which(deaths.agg$Date=="2020-03-31"),]
march_r <- recovered.agg[which(recovered.agg$Date=="2020-03-31"),]

#Ordering the data by value
top_march_c <- march_c[order(-march_c$Value),][1:10,]
top_march_d <- march_d[which(march_d$Country.Region %in% top_march_c$Country.Region),]
top_march_r <- march_r[which(march_r$Country.Region %in% top_march_c$Country.Region),]

top_march_c <- top_march_c[order(top_march_c$Country.Region),] 
top_march_d <- top_march_d[order(top_march_d$Country.Region),] 
top_march_r <- top_march_r[order(top_march_r$Country.Region),]

#Prepering the data for the barplot
country <- top_march_c$Country.Region
cases <- top_march_c$Value
deaths <- top_march_d$Value
recovered <- top_march_r$Value
#Adding a new column - sick
sick <- cases - deaths - recovered
total_cases <- cases
march_data <- data.frame(total_cases, sick, deaths, recovered)
march_data <- march_data[order(-march_data$total_cases),]
march_t <- transpose(march_data)
top_march_c <- march_c[order(-march_c$Value),][1:10,]
rownames(march_t) <- colnames(march_data)
colnames(march_t) <- top_march_c$Country.Region
march_t <- march_t[-c(1),] #Removing the row that we no longer need for the plot


#Creating stacked bar plot of the top ten countries with corona cases
barplot(as.matrix(march_t), main= "Top ten countries:cases, deaths ,recovered corona- March 2020", cex.names = 0.45, col = c("bisque1","firebrick1","darkorchid1"), xlab="Countries", ylab = "Corona Cases",  ylim= c(0, 200000))
legend("topright",title="Legend:", c("Sick","Deaths", "Recovered"), fill = c("bisque1","firebrick1","darkorchid1"))
text(march_t, labels=)

```


**Q1.d.**

**In the barplot you can see the top ten countries with corona cases stacked with the sick people, the numbers of deaths from corona and the recovered people for every country. You can see that Us is the country with the highest number of corona cases, and you can notice that china, which was the first one with corona, has the highest number of recovered cases.The number of recoverers rises as the country was among the first to be affected and is low for those still in the middle of the epidemic.** 

**In our opinion, the problem of presenting the information in such a way is that we losse information about whether there is any trend in the data and it is also difficult to notice the difference between countries in the different cases (death, sick and recoverers). They all displayed in stacked and not separately. Choosing the end of March date also gives misleading information. Some countries have already undergone the epidemic (China) while some are under way (Italy). We note that with this method the numbers are not normalized to the country's population and therefore the comparison is biased**

<br/><br/>  

### Q2
### Analysis of Daily New Corona Cases and Deaths  
20 points

The two datasets (Corona Cases and Deaths) register the value of cases and deaths, respectively, as a cumulative sum for each day. In this question we would like to understand the daily differences between consecutive days.     

a. Add a new column named `Diff` to both the `cases.agg` and the `deaths.agg` data-frames. This new column should register the daily `Value` difference for each country. In other words, the `Diff` column shows how many new cases/deaths each country incurs every day. Hint - diff must be per country. (7pts)  
b. Find the top 10 instances of country and date combinations with the greatest absolute number of new daily Corona cases and deaths (separately). Print the result in a descriptive format. (5pts)  
c. In one figure, plot Italy's new daily Corona cases AND deaths as a function of Date. Choose the plot type you think that makes the most sense. (3pts) 
d. Plot the same graph as in (c), but this time plot the number of new cases on the logarithm scale. What can we learn? (5pts)-  

  
**Solution:**

**Q2.b.**
**we created new columns for death and corona cases that displays the day-to-day changes in values so that the rate of change can also be checked. We used a loop that subtracts two consecutive days and creates a column of changes called Diff.**

**method:We found the unique values of the date and checked the differences for each country every two days and with a loop we created a new vector that shows the changes. In the end we added that vector as a new column to the data.**
```{r}
#a
#Finding the unique values on cases
dates <- unique(cases.agg$Date)

#Filter the data cases from the day the corona start
first_day_cases <- cases.agg[which(cases.agg$Date=="2020-01-22"),]
#Creating a column for the first day to compare to
diff_cases <- first_day_cases$Value

#Creating the Diff column by compraing two days and adding to the value in a loop
#the cases:
for (day in dates){
  new_day <- cases.agg[which(cases.agg$Date==day + 1),]
  new_val <- new_day$Value
  old_day <- cases.agg[which(cases.agg$Date==day),]
  old_val <- old_day$Value
  val <- new_val - old_val
  diff_cases <- c(diff_cases, val)
}
cases.agg <- cases.agg[order(cases.agg$Date),]
cases.agg$Diff <- diff_cases
cases.agg <- cases.agg[order(cases.agg$Country.Region),]

#the deaths:
first_day_deaths <- deaths.agg[which(deaths.agg$Date=="2020-01-22"),]
diff_deaths <- first_day_deaths$Value

for (day in dates){
  new_day <- deaths.agg[which(deaths.agg$Date==day + 1),]
  new_val <- new_day$Value
  old_day <- deaths.agg[which(deaths.agg$Date==day),]
  old_val <- old_day$Value
  val <- new_val - old_val
  diff_deaths <- c(diff_deaths, val)
}
deaths.agg <- deaths.agg[order(deaths.agg$Date),]
deaths.agg$Diff <- diff_deaths
deaths.agg <- deaths.agg[order(deaths.agg$Country.Region),]
```
**b.**
**We found the top ten countries with the greatest absolute number of new daily Corona cases and deaths using the new columns Diff we created and ordering the columns by value.** 
```{r}
#b
#find the top 10 countries with new cases and deaths combining date and country
new_cases <- cases.agg[order(-cases.agg$Diff),][1:10,]
new_deaths <- deaths.agg[order(-deaths.agg$Diff),][1:10,]

top_cases <- select(new_cases, Country.Region, Date, Diff)
top_deaths <- select(new_deaths, Country.Region, Date, Diff)
```

**The two tables presenting the top ten countries with new corona cases and corona's deaths. We ordered the cases by the coloumn Diff.cases from the largest to smalles and the same for deaths and then we chose the top ten for each data. We chose to present as tables the columns :country.region' date and diff because we thought they represent important and relevant information. This way of presenting the data creates a clear and simple format for reading the data.**

```{r}
as_tibble(top_cases) #Presenting the data (cases) as a table (tibble)
as_tibble(top_deaths)
```

**c.**
**We filtered the data with the country italy and the column Diff for the corona cases and the corona deaths and then we presented the data in a lines plot.**

```{r}
#c
#Creating the data for the plot of italy by date and cases and deaths
italy_cases <- cases.agg[which(cases.agg$Country.Region== "Italy"),c(2,4)]
italy_deaths <- deaths.agg[which(deaths.agg$Country.Region== "Italy"),c(2,4)]
plot(italy_cases$Date, italy_cases$Diff,type="l", lwd= 2, xlab = "Date", ylab = "Value - corona cases and deaths", main= "Italy- daily corona deaths and new cases by date ", col= "red", las=1, ylim=c(0, 7000))
lines(italy_deaths$Date, italy_deaths$Diff,type="l", lwd= 2, col= "blue")
legend("topleft",title="Legend:", c("Cases", "Deaths"), col= c("red", "blue"), lty = c(1, 1))
```

**In this gragh you can see the daily corona cases and deaths in Italy from February to April. We used lines in the gragh to show the trend lines of corona cases and deaths. In the gragh you can see that the cases number and the deaths number are growing together and there is a tight connection between them in Italy. You can see when the one is increasing or decreasing so does the other.**

```{r}
#d
plot(italy_cases$Date, log(italy_cases$Diff),type="l", lwd= 2, xlab = "Date", ylab = "Value", main= "Italy- daily deaths and new cases (in log)",pch = 8, col= "red", las=1)
lines(italy_deaths$Date, log(italy_deaths$Diff),type="l", lwd= 2, col= "blue", pch= 16, ylim= c(0, 12))
legend("topleft",title="Legend:", c("Cases", "Deaths"), col= c("red", "blue"), lty = c(1, 1))
```

**Q2.d.**
**In this gragh you can see daily corona cases and  deaths in Italy from February to April. We used logarithem scale on the cases and deaths. We can learn from the graph that the deaths and new cases increase at a similair rate, parallel to eachother.**

<br/><br/>


### Q3
### Preparing and Analyzing the World Bank Data   
25 points

a. Rename the columns of `eco_data`: `country,S_country,feature,feature_code,Y2018V,Y2019V`. (2pts)  
b. Create a new `eco` data-frame whose dimensions are $266 \times 11$. The first column should include the names of the countries in `eco_data.`   
The rest of the columns should be the features with their respective values in `eco_data` for each country from 2018. Print the head of the new data-frame.(8pts)  
c. Select and rename the following columns: `country` as country, `GDP(US currency)` as GDP, `Population ages 65 and above (% of total population)` as pop65, `Population in the largest city (% of urban population)` as pop_city_ratio, `Population, total` as pop_total columns .  (2pts) 
d. Show a table of the five countries with the highest per capita GDP in 2018.     
Next (considering all countries), plot the % of population over 65 vs. log of GDP per capita in 2018, after excluding the 10% countries with the lowest GDP per capita. Using `lm` and `abline`, add a regression line to the plot. What is your conclusion? (13 pts)  
  

  
**Solution:** 

**Q3.**

**we loaded the eco data and changed the columns names to more representative names.You can see the new columns names in the printing. **
```{r}
#a
eco_data <- read.csv(url("https://raw.githubusercontent.com/DataScienceHU/DataAnalysisR_2020/master/data/economic_data.csv"), header = T)

#Changing the columns names
colnames(eco_data) <- c( "country","S_country","feature","feature_code","Y2018V","Y2019V")
print(colnames(eco_data))
```

**b.**
**we took the information we loaded from the Internet and changed it from a long to wide format, creating new columns that include country and the unique values that were in the column feature and the columns value that came from column Y2018. We used the dcast function we learn about in class. We also erase the first line in the data because it was empty and the same for the first column.**
**In the process we received error notes that we gave the function dcast data frame instead of data table and we are aware of it and still prefer this format. Indeed, we made sure we didn't lose any information. When we tried to use the sum function on dcast in the column "Y2018" the information went wrong , to fix that we changed the column type to numeric.**

 
```{r}
#b
eco <- eco_data[,c("country", "feature", "Y2018V")]
eco$Y2018V <- as.numeric(as.character(eco$Y2018V))
eco <- dcast(eco, country~feature, value.var="Y2018V", fun.aggregate= sum, na.rm= TRUE)
eco$Var.2 <- NULL
eco <- eco[-c(1),]
```

**You can see that the dim of the data is 266 on 11 as you instructed.**
**You can see the head of the data frame.**

```{r}
dim(eco)
head(eco)
```

**c.**
**We renamed the names of the columns as you can see by printing the columns names.**
```{r}
#c
#Select the columns and rename
names(eco)[c(1, 3, 6, 7, 8)] <- c("country", "GDP","pop65","pop_city_ratio", "pop_total_columns") 
print(colnames(eco))
```

**d.**
**we took the eco data and arranged it according to GDP per capita. Then we changed the data format to tibble and print the top five countries with the highest GDP per capit. We thought it most relevant and focused to print the name of the country and the GDP per capita value in the table.**

```{r}
#d
eco <- as.data.frame(eco)
eco_new <- eco
eco_new$GDP_per_capita <- eco_new$GDP %/% eco_new$pop_total_columns
eco_new <- eco_new[order(-eco_new$GDP_per_capita),]
top_eco <- eco_new[1:5,c("country", "GDP_per_capita")]
top_eco <- as.data.table(top_eco)
print(top_eco)

data_len <- length(eco_new$country)*0.9
eco_new <- eco_new[1:data_len,c("country", "pop65", "GDP_per_capita")]
```

**We arranged the data in descending order and by finding the data length and multiplying it by 0.9, We used this metric to cut the data, thus erasing ten percent of the countries with the lowest values.**

```{r}
plot(eco_new$pop65, log(eco_new$GDP_per_capita), xlab= "% of population over 65", ylab= "log (GDP_per_capita)", main = "% of population over 65 vs. log of GDP per capita in 2018", pch= 16, col= "darkturquoise")
abline(lm(log(eco_new$GDP_per_capita) ~ eco_new$pop65), col= "purple", lwd=3)
legend("bottomright",title="Legend:", c("Regression line", "countries"), col= c("darkturquoise", "purple"), lty=c(1, NA), pch=c(NA, 16))
```

**d.**

**The graph shows log of GDP per capita against the percentage of the population over 65 in the different countries. We also added a regression line to show the trend. It can be seen that as the percentage of older people increases, so does GDP per capita, but that stops in the region of 20 and a few percent of adults.** 

**Surprisingly after examining the plot, it seems that in most countries as the percentage of people over 65 increases, so does the GDP per capita (in 2018).We noticed that the information is scattered around the regression line so there is no clear trend between all the countries**


<br/><br/>  

### Q4
### Joining the Datasets   
20 points

a. Join the `deaths.agg`, `cases.agg`, and `recovered.agg` into one data-frame called `corona`.(5pts)
b. Join the `corona` and `eco` data-frames in a way that will keep the most information regarding the data (but not full join).   
Make sure that no essential data is thrown away (show this). (3pts)
c. Create new columns of normalized `cases`, `deaths`, and `recovered` so they will show the number of cases per 100,000 people for each country.   
Using the last day of March as a reference, create a single stacked bar plot that visualizes the top 10 countries in terms of normalized Corona cases, and their respected normalized Corona deaths and recovered, as done in Q1.   
how is it different from the graph before normalization? (5pts)
d. Using the last day of March as a reference, create a scatter-plot of normalized deaths and cases vs. `pop65`. Limit the plot to show only countries with 15% or more of `pop65`.   
In addition, colorcorona <- the outliers( pop65>24, norm100K_deaths>15) in that plot in red and add to the plot their country names (7pts)
  
**Solution:**

**Q4.**

**a.**
**We changed the named of the columns in the aggregated data from Q1 and full join the three data's: cases, deaths and recovered. A full join guarantees we don't lose any information. We first full joined the deaths data and the recovered data and then we full joined the new data and the cases data and at the end we got the corona data that contains everything.**
```{r}
#a
names(deaths.agg)[3] <- "Deaths"
names(recovered.agg)[3] <- "Recovered"
names(cases.agg)[3] <- "Cases"

names(deaths.agg)[4] <- "Diff.deaths"
names(cases.agg)[4] <- "Diff.cases"
```

**b.**
**We checked the two data frames before joining them (not a full join) there are country names with different spelling. To avoid loosing data we change manualy the names to match. In addition we found that there are 4 countries in one data frame (eco) and not in the other.These four countries are not important to our reaserch therfore it is ok their values are NA, and does not interfere with the data analysis. We used anti join to track the differences in the data.** 
**It is important to note that there is one state, Taiwan, which is missing in the eco data (subject to China) even though it is a state in itself in the corona data, therfore her values will be NA and we notice it.**

```{r}
#Changing countries name that are different in the two data frames, for not losing data
corona <- full_join(deaths.agg, recovered.agg, by = c("Country.Region", "Date"))
eco$country <- as.character(eco$country)
eco$country[eco$country == "United States"] <- "US"
eco$country[eco$country == "Czech Republic"] <- "Czechia"
eco$country[eco$country == "Slovak Republic"] <- "Slovakia"
eco$country[eco$country == "Russian Federation"] <- "Russia"
eco$country[eco$country == "Myanmar"] <- "Burma"
eco$country[eco$country == "Gambia, The"] <- "Gambia"
eco$country[eco$country == "Yemen, Rep."] <- "Yemen"
eco$country[eco$country == "Korea, Rep."] <- "Korea, South"
eco$country[eco$country == "St. Lucia"] <- "Saint Lucia"
eco$country[eco$country == "Syrian Arab Republic"] <- "Syria"
eco$country[eco$country == "Venezuela, RB"] <- "Venezuela"
eco$country[eco$country == "St. Kitts and Nevis"] <- "Saint Kitts and Nevis"
eco$country[eco$country == "Lao PDR"] <- "Laos"
eco$country[eco$country == "Iran, Islamic Rep."] <- "Iran"
eco$country[eco$country == "Egypt, Arab Rep."] <- "Egypt"
eco$country[eco$country == "Congo, Dem. Rep."] <- "Congo (Kinshasa)"
eco$country[eco$country == "Brunei Darussalam"] <- "Brunei"
eco$country[eco$country == "Sub-Saharan Africa"] <- "Western Sahara"
eco$country[eco$country == "St. Vincent and the Grenadines"] <- "Saint Vincent and the Grenadines"
eco$country[eco$country == "Kyrgyz Republic"] <- "Kyrgyzstan"
eco$country[eco$country == "Congo, Rep."] <- "Congo (Brazzaville)"
eco$country[eco$country == "Bahamas, The"] <- "Bahamas"
eco$country <- as.factor(eco$country)
corona<- full_join(corona, cases.agg, by = c("Country.Region", "Date"))
```


```{r}
#b
names(corona)[1] <- "country"
cor_eco <- left_join(corona, eco, by="country")
# how we didnt lose any data when useing this join
```

**c.**
**We have created normalized columns (the information is divided by 100,000) for corona deaths, corona deaths, and recovery from it. We then filtered by date and arranged and found the first ten countries with the most cases normalized to population size.**

```{r}
#c
cor_eco$nor_cases <- (cor_eco$Cases) / ((cor_eco$pop_total_columns) / 100000)
cor_eco$nor_deaths <- (cor_eco$Deaths) / ((cor_eco$pop_total_columns) / 100000)
cor_eco$nor_recovered <- (cor_eco$Recovered) / (cor_eco$pop_total_columns / 100000)

cor_eco_march <- cor_eco[which(cor_eco$Date=="2020-03-31"),c("country", "Date", "nor_cases", "nor_deaths", "nor_recovered")]
cor_eco_march_10 <- cor_eco_march[order(-cor_eco_march$nor_cases),][2:11,]
#Eritrea's population in the data is 0 and so the normalized corona cases came out inf. That is way we excluded them from the top 10 countries.#to print/ write 

norm_cases <- cor_eco_march_10$nor_cases
norm_deaths <- cor_eco_march_10$nor_deaths
norm_recovered <- cor_eco_march_10$nor_recovered
norm_sick <- norm_cases - norm_deaths - norm_recovered
nor_march_data <- data.frame(norm_sick, norm_deaths, norm_recovered)
nor_march_t <- transpose(nor_march_data)
rownames(nor_march_t) <- colnames(nor_march_data)
colnames(nor_march_t) <- cor_eco_march_10$country

barplot(as.matrix(nor_march_t), main= "Top ten countries normalized corona March 2020", cex.names = 0.5, col = c("bisque1","firebrick1","darkorchid1"), xlab="Countries", ylab = "Corona normalized Cases", las=1, ylim=c(0,700))
legend("topright",title="Legend:", c("Sick","Deaths", "Recovered"), fill = c("bisque1","firebrick1","darkorchid1"))
```

**c.**
**Eritrea's population in the data is 0 and so the normalized corona cases came out inf. That is why we excluded her from the top ten countries**

**This graph shows the ten countries with the most normalized corona case population divided into deaths, sick and recovered people.**

**We notice that the top ten countries in the original graph are mostly countries with large populations. The normalized graph allows us to get a better picture of corona cases in proportion to the countries population. That is why in this graph smaller countries such as Luxenburg (one of the smallest countries in the world) appear as well.**

```{r}
#d
cor_eco_march <- cor_eco[which(cor_eco$Date=="2020-03-31"),]
flt_march <- nor_march_data
flt_march <- cor_eco_march[which(cor_eco_march$pop65 >= 15),]

plot(flt_march$pop65, flt_march$nor_cases, xlab = "% population over age 65", ylab = "Corona cases and deaths", main= "Corona cases and deaths vs. % population over age 65", pch =c(16), col=ifelse(flt_march$pop65 >24,'red','blue'), las=1, ylim=c(0,250), xlim=c(15, 30))
points(flt_march$pop65, flt_march$nor_deaths, col= ifelse(flt_march$pop65 >24 | flt_march$nor_deaths>15,'red','green'), pch= 16)
legend("topright",title="Legend:", c("Cases", "Deaths", "Pop65>24", "Deaths >15"), col= c("blue", "green", "red", "red"), pch = c(16, 16, 16, 16))
text(flt_march$nor_cases ~ flt_march$pop65, labels=ifelse(flt_march$pop65>24, flt_march$country, ""), pos=4, cex=0.8)
text(flt_march$nor_deaths~ flt_march$pop65, labels=ifelse(flt_march$nor_deaths >15, flt_march$country, ""), pos=4, cex=0.8)

```

**d.**

**This graph shows the cases of corona and death in the all the countries (whose percentage of their population over 65 is at least 15) vs. the percentage of the population aged over 65. It can be noted that up to about 20 percent and some of the quantities actually increase with the respective population but then it ceases. The red shows the exceptional states where the number of dead is over 15% and the percentage of adults over 24%. The country Japan is the only one that has over a 24 percentage of people over 65 and over 15 percent of deaths. In addition, Italy and Spain have over 15 percent dead and are therefore also painted red, like Japan.**


<br/><br/>  

### Q5
### Open Question
10 points
  
Write an interesting research question regarding the Corona outbreak and then follow the steps to answer it using tables and plots. You can use the loaded datasets or any other dataset you find as long as you add the data file to your `lab1` repository so it can be loaded directly from a `url` (e.g. the World Bank). This question will be graded based on creativity, originality, and the novelty of the analysis.

** Oue reasearch question :
How many deaths there is in general year between months january to april and how many in 2020 with the Corona?
Does the deaths rate is different? Does corona is so bad like cancer in the deaths rate or less?**
  
**Solution:**   

![forbes](https://github.com/DataScienceHU/52414-lab-1-baitner_amit_and_solomon_ayelet/blob/master/%E2%80%8F%E2%80%8Fforbes_women_leaders.JPG?raw=true)

**During this difficult period the two have us have been following the Israeli news. We noticed that most if not all of the people leading this crisis in the country are men. In addition we saw many articals saying the countries that are doing best corona responses are countries with women as leaders. As this raised some questions relating woman leadership We decided to research and compare the spreading of COVID19 in developed countries (included in the OECD) led by woman as oppose to countries led by men. We will answer the question using different plots and comparing the countries led by woman with those led by men.**

**Research Question: Is there a difference in the effects of corona on OECD countries led by men vs. women?**


**First we create the relevent vectors and data frames (filtered out the OECD countries from the corona data farme).**
```{r}
#OECD countries included in the list found on official OECD website
oecd_countries <- c("Australia", "Austria", "Belgium", "Canada", "Chile", "Czechia", "Denmark", "Estonia", "Finland", "France", "Germany", "Greece", "Hungary", "Iceland", "Ireland", "Israel", "Italy", "Japan", "Korea, South", "Latvia", "Lithuania", "Luxembourg", "Mexico", "Netherlands", "New Zealand", "Norway", "Poland", "Portugal", "Slovenia", "Slovakia", "Spain", "Sweden", "Switzerland", "Turkey", "United Kingdom", "US")

#All countries in the world currently led by woman
wom_countries <- c("Germany", "Bangladesh", "Norway", "Namibia", "Nepal", "Myanmar", "Taiwan", "Estonia", "Serbia", "Singapore", "New Zealand", "Iceland", "Trinidad and Tobago", "Barbados", "Ethiopia", "Georgia", "Slovakia", "Denmark", "Belgium", "Bolivia", "Finland", "Greece")

oecd_cor_eco <- cor_eco[which(cor_eco$country %in% oecd_countries), c("country", "Date", "Diff.deaths", "Diff.cases", "Cases", "Deaths", "nor_cases", "nor_deaths", "nor_recovered", "pop_total_columns")]

oecd_w_cor_eco <- oecd_cor_eco[which(oecd_cor_eco$country %in% wom_countries),]
`%notin%` <- Negate(`%in%`)
oecd_m_cor_eco <- oecd_cor_eco[which(oecd_cor_eco$country %notin% wom_countries),]


``` 



**We then filter the information for the last day of March (using this day as an example in the peek of the corona crisis) and present all OECD countries with normalized corona and normalized deaths. In the graph, we color pink the countries led by women and blue those led by men and arranged in ascending order. We decided to use normalized data in order to avoid distortion of the data due to the diffrenet sized population.**

```{r}

#Creating data including only the 31st of March.
oecd_march <- oecd_cor_eco[which(oecd_cor_eco$Date=="2020-03-31"),]
oecd_march <- oecd_march[order(-oecd_march$nor_cases),] 
oecd_march$country[oecd_march$country == "United Kingdom"] <- "UK"

#gragh for the oecd countries for normalized corona cases.
barplot(oecd_march$nor_cases, names.arg = oecd_march$country, main= "Normalized corona cases March OECD countries", cex.names = 0.5, col = ifelse(oecd_march$country %in% wom_countries,"deeppink", "cadetblue1"), xlab="Countries", ylab = "Corona normalized cases", las=2, ylim=c(0,500))
legend("topright", c("Led by men", "Led by Women"), fill = c("cadetblue1","deeppink"))

oecd_march <- oecd_march[order(-oecd_march$nor_deaths),]
oecd_march$country[oecd_march$country == "Korea, South"] <- "S.Korea"

barplot(oecd_march$nor_deaths, names.arg = oecd_march$country, main= "Normalized corona deaths March OECD countries", cex.names = 0.5, col = ifelse(oecd_march$country %in% oecd_w_cor_eco$country,"deeppink", "cadetblue1"), xlab="Countries", ylab = "Corona normalized deaths", las=2, ylim=c(0, 25))
legend("topright", c("Led by men", "Led by Women"), fill = c("cadetblue1","deeppink"))

```

**Both graphs (of normal corona cases and of normal corona deaths) show that there is no obvious difference between women and men led countries. The countries led by women are spread out pretty evenly in between those led by men. To conclude from this analysis that women do not necessarily lead countries better or worse at the time of the epidemic, we note that the normalized numbers can be compared across countries despite a different population.**

**It can be seen that contrary to the media's presentation, both in the Corona cases and in the deaths the women led countries are not in the lowest and not the highest places but relatively in the middle and therefore cannot be said to cope better with the plague with this speceific analysis.**

**In order to get more information to support our conclusion we created columns with normalized difference of corona deaths and cases daily."**

```{r}
#We normalized the columns: Diff.cases, Diff.deaths
oecd_cor_eco$Diff.nor_cases <- (oecd_cor_eco$Diff.cases) / ((oecd_cor_eco$pop_total_columns) / 100000)
oecd_cor_eco$Diff.nor_deaths <- (oecd_cor_eco$Diff.deaths) / ((oecd_cor_eco$pop_total_columns) / 100000)

#Creating seperate data for countries led by woman and men
oecd_cor_eco_w <- oecd_cor_eco[which(oecd_cor_eco$country %in% wom_countries),]
`%notin%` <- Negate(`%in%`)
oecd_cor_eco_m <- oecd_cor_eco[which(oecd_cor_eco$country %notin% wom_countries),]
```

**For further review, we decided to normalize the Diff columns showing the rate of increase in patients and the dead and compared this rate for women-led and men-led countries using different colors."**

```{r}

#Plotting normalized daily diff cases OECD countries
plot(oecd_cor_eco[which(oecd_cor_eco$country == "Australia"),"Date"], oecd_cor_eco[which(oecd_cor_eco$country == "Australia"),"Diff.nor_cases"],type="l", lwd= 1, xlab = "Date", ylab = "Daily value differences", main= "OECD Diff normalized corona cases",pch = 8, col= "gray48", las=1, ylim = c(0, 40))
for (c in oecd_countries){
  lines(oecd_cor_eco[which(oecd_cor_eco$country == c),c(2)], oecd_cor_eco[which(oecd_cor_eco$country == c),c(11)],type="l", lwd= 1, col = ifelse(c %in% wom_countries,"deeppink", "gray48"), pch= 16)
}
legend("topleft", c("led by women", "led by man"), col= c("deeppink", "gray48"), lty = c(1, 1))

#Plotting normalized daily diff deaths OECD countries
plot(oecd_cor_eco[which(oecd_cor_eco$country == "Australia"),"Date"], oecd_cor_eco[which(oecd_cor_eco$country == "Australia"),"Diff.nor_deaths"],type="l", lwd= 1, xlab = "Date", ylab = "Daily value differences", main= "OECD Diff normalized corona deaths",pch = 8, col= "gray48", las=1, ylim = c(0, 5))
for (c in oecd_countries){
  lines(oecd_cor_eco[which(oecd_cor_eco$country == c),"Date"], oecd_cor_eco[which(oecd_cor_eco$country == c),"Diff.nor_deaths"],type="l", lwd= 1, col = ifelse(c %in% wom_countries,"deeppink", "gray48"), pch= 16)
}
legend("topleft", c("led by women", "led by man"), col= c("deeppink", "gray48"), lty = c(1, 1))
```


**Although it is not a very clear or accurate way to compare, we do not notice any particular differences in the way the data is distributed.**
**In order to compare in a more clear way, we aggregate the woman and men data sets averaging the normalized Diff we created in the previous part.**

```{r}
#Agrregating the data to create avegrage Diff.nor_cases and Diff.nor_deaths
w_average_cases <- aggregate(Diff.nor_cases ~ Date, data = oecd_cor_eco_w, FUN = mean)
m_average_cases <- aggregate(Diff.nor_cases ~ Date, data = oecd_cor_eco_m, FUN = mean)

w_average_deaths <- aggregate(Diff.nor_deaths ~ Date, data = oecd_cor_eco_w, FUN = mean)
m_average_deaths <- aggregate(Diff.nor_deaths ~ Date, data = oecd_cor_eco_m, FUN = mean)

#Plotting average normalized daily diff cases for countries led my men and women
plot(w_average_cases$Date, w_average_cases$Diff.nor_cases,type="l", lwd= 2, xlab = "Date", ylab = "Average daily value differences", main= "Avr. OECD DIff.nor_cases - led by men vs women",pch = 8, col= "deeppink", las=1, ylim = c(0, 10))
lines(m_average_cases$Date, m_average_cases$Diff.nor_cases,type="l", lwd= 2, col =  "blue", pch= 16, ylim= c(0, 12))
legend("topleft", c("led by women", "led by man"), col= c("deeppink", "blue"), lty = c(1, 1))

##Plotting average normalized daily diff deaths for countries led my men and women
plot(w_average_deaths$Date, w_average_deaths$Diff.nor_deaths,type="l", lwd= 2, xlab = "Date", ylab = "Average daily value differences", main= "Avr. OECD DIff.nor_deaths - led by men vs women",pch = 8, col= "deeppink", las=1, ylim = c(0, 1))
lines(m_average_deaths$Date, m_average_deaths$Diff.nor_deaths,type="l", lwd= 2, col =  "blue", pch= 16)
legend("topleft", c("led by women", "led by man"), col= c("deeppink", "blue"), lty = c(1, 1))

```


**Here we get a pretty clear picture there is no significant difference between the two graphs. This strengthens our previous conclusion there is no difference between women and men led countries from another and different perspective on the data.**


**To complete our research we load a data presenting the amount of corona tests (per 1000 citizens) that were sampled in every country (notice the data we found was available for 33 out of 36 countries in the OECD so we exclused the others from this part of the research). The data is from the website "Our world in data" (relates to Oxpord university). We believe the amount of tests a country sampled (reletavly to their population) indicates how well they have been handling the epidemic, a larger number of tests meaning they delt better. Note, we also realise that a country that appears to have more cases may not necceseraly be doing worse because they may have not tested people who are possibly sick. The amount of cases can also be due to culture or the amount of traveling done in the country prior to the official start of the epidemic. All those reasons do not have to do with the leadership of the country and that is way we believe comparing the amount of tests is a good way to compare.**

**Note the information in this data updated until April 23. That is all we needed for this research.**
```{r}
corona_tests <- read.csv(url("https://raw.githubusercontent.com/DataScienceHU/52414-lab-1-baitner_amit_and_solomon_ayelet/master/full-list-cumulative-total-tests-per-thousand.csv"),header=TRUE)

corona_tests[2] <- NULL
corona_tests[2] <- NULL
names(corona_tests)[1] <- "country"
names(corona_tests)[2] <- "Total_tests_per_1000"
#corona$Date <- as.Date(corona_tests$Date)
#class(corona_tests$Date)

corona_tests <- corona_tests[which(corona_tests$country %in% oecd_countries),]
unique(corona_tests$country)

cor_test_agg <- aggregate(Total_tests_per_1000 ~ country ,data= corona_tests, FUN=sum)
cor_test_agg <- cor_test_agg[order(-cor_test_agg$Total_tests_per_1000),]

barplot(cor_test_agg$Total_tests_per_1000, names.arg = cor_test_agg$country, main= "Total corona tests per 1000 in the OECD countries (23.04.20)", cex.names = 0.5, col = ifelse(cor_test_agg$country %in% oecd_w_cor_eco$country,"deeppink", "cadetblue1"), xlab="Countries", ylab = "Corona normalized tests", las=2, ylim=c(0, 3000))
legend("topright",title= "Legend:", c("Led by men", "Led by Women"), fill = c("cadetblue1","deeppink"))
```


**In this gragh you can notice that iceland, led by a woman, is with the highest by far among the other countries with number of corona test, but the rest of the countries led by women and men are spread out evenly this final plot is consistint with our previous ones, indicating no difference between men and women leadership during corona.**

**Therefor our final conclusion is that condradicting the media and and stereotypes in either direction, men and women are equaly capable of handling situations such as this epidemic. We are proud and appreciative living in a time women are free to hold important roles such as leading some of the greatest countries in the world. We enjoyed this research and learned a lot, we thank you for this opportunity.**

**Ayelet and Amit.**

<br/><br/>  

